TODO:

!!! Sometimes in Fib, gc4 gets converted from an ArrayVar to Var

(0) Need a better way to track which vars are arrays...
    - Add a Array ArithExp to VCGen
    - Modify GuardedConditions.AssumEquals to specify an ArithExp and ArithExp,
      allowing Array-Array and Var-Var
    - Fix all occurrences of ^
(1) Pass in precondition as starting weakest pre-condition
(2) AND weakest precondition with post-condition


****

(x) Install z3
(x) Get all array vars used in an Assertion
(x) Get all non-array vars used in an Assertion
(x) Remove all Forall(...) and replace Exists(...) with negation
(5) Change naming convention so # -> _ and $ -> __
(6) Print out z3-string


****

(x) Finish WeakestPrecondition.boolExpToAssertion conversion (easy)
(x) Finish WeakestPrecondition.wp
  - For GCAssume(GCBoolExp(b)) do implies(boolExpToAssertion(b), a)
  - For GCInvariant(i) do implies(i, a)
  - Rest should be fairly easy...

**** 


(x) Make wp.scala
(x) Make a function wp(GC, VCGen.Assertion) : VCGen.Assertion
  - make a trait Condition that's either Assertion or WriteClause(x, a, i, v)
  - make a function wp(GC, Condition) for heavy-lifting
      - make a new getFreshVar
      - make a new replace(VCGen.Assertion)
      - make a assumptionToCondition(GCAssume(a)) function since that's beefy
      - make a case for assume ^, havoc, seq, branch, and assertion
(3) Figure out when to use \forall and when to use \exists

****

Thoughts:
 - Might need to differentiate Var(x) from Arr(x)
 - How is it language specifies if-then or if-then-else but we only handle
   if-then-else?

